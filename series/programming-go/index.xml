<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang 编程 on 博客</title>
    <link>https://blog.srcio.cn/series/programming-go/</link>
    <description>Recent content in Golang 编程 on 博客</description>
    <image>
      <url>https://blog.srcio.cn/cover.png</url>
      <link>https://blog.srcio.cn/cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 28 Sep 2022 18:23:19 +0800</lastBuildDate><atom:link href="https://blog.srcio.cn/series/programming-go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 实现双向认证</title>
      <link>https://blog.srcio.cn/series/programming-go/mtls/</link>
      <pubDate>Sun, 02 Oct 2022 01:49:13 +0800</pubDate>
      
      <guid>https://blog.srcio.cn/series/programming-go/mtls/</guid>
      <description>TLS 传输层安全协议（TLS），在互联网上，通常是由服务器单向的向客户端提供证书，以证明其身份。
mTLS 双向 TLS 认证，是指在客户端和服务器之间使用双行加密通道，mTLS 是云原生应用中常用的通信安全协议。
使用双向TLS连接的主要目的是当服务器应该只接受来自有限的允许的客户端的 TLS 连接时。例如，一个组织希望将服务器的 TLS 连接限制为只来自该组织的合法合作伙伴或客户。显然，为客户端添加IP白名单不是一个好的安全实践，因为IP可能被欺骗。
为了简化 mTLS 握手的过程，我们这样简单梳理：
  客户端发送访问服务器上受保护信息的请求；
  服务器向客户端提供公钥证书；
  客户端通过使用 CA 的公钥来验证服务器公钥证书的数字签名，以验证服务器的证书；
  如果步骤 3 成功，客户机将其客户端公钥证书发送到服务器；
  服务器使用步骤 3 中相同的方法验证客户机的证书；
  如果成功，服务器将对受保护信息的访问权授予客户机。
  代码实现 需要实现客户端验证服务端的公钥证书，服务端验证客户端的公钥证书。
生成证书 echo &amp;#39;清理并生成目录&amp;#39; OUT=./certs DAYS=365 RSALEN=2048 CN=srcio rm -rf ${OUT}/* mkdir ${OUT} &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1 cd ${OUT} echo &amp;#39;生成CA的私钥&amp;#39; openssl genrsa -out ca.key ${RSALEN} &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1 echo &amp;#39;生成CA的签名证书&amp;#39; openssl req -new \ -x509 \ -key ca.</description>
    </item>
    
    <item>
      <title>Go1.18 - 工作区模式</title>
      <link>https://blog.srcio.cn/series/programming-go/go-work/</link>
      <pubDate>Wed, 28 Sep 2022 18:25:05 +0800</pubDate>
      
      <guid>https://blog.srcio.cn/series/programming-go/go-work/</guid>
      <description>安装的 Go1.18 或更新版本，它为你提供了工作区模式（Workspace mode），帮助你更好做 go 模块之间依赖的管理。
例如，你开发一个新项目，分了两个 go module，分别为 service-a 和 service-b，service-a 依赖了service-b ，现在项目还处于开发阶段，我们都是这么处理的。
创建项目目录：
mkdir service cd service 创建 service-b 模块:
mkdir service-b cd service-b go mod init github.com/srcio/service-b 编写 service-b 模块代码：
mkdir greeting vim greeting/hello.go package greeting import &amp;#34;fmt&amp;#34; func Hello(name string){ fmt.Println(&amp;#34;Hello, &amp;#34; + name) } 继续创建 service-a 模块：
cd .. mkdir service-a cd service-a go mod init github.com/srcio/service-a 因为 service-a 需要依赖本地开发的 service-b 类库，所以我们需要在 go.mod 中引入 service-a ：</description>
    </item>
    
  </channel>
</rss>
