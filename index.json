[{"content":"安装最新的Go1.18版本，它为你提供了工作区模式，帮助你轻松依赖本地类库。\n例如，你开发一个新项目，分了两个 go module，分别为 service-a 和 service-b，service-a 依赖了service-b ，现在项目还处于开发阶段，我们都是这么处理的。\n创建项目目录：\nmkdir service cd service 创建 service-b 模块:\nmkdir service-b cd service-b go mod init github.com/srcio/service-b 编写 service-b 模块代码：\nmkdir greeting vim greeting/hello.go package greeting import \u0026#34;fmt\u0026#34; func Hello(name string){ fmt.Println(\u0026#34;Hello, \u0026#34; + name) } 继续创建 service-a 模块：\ncd .. mkdir service-a cd service-a go mod init github.com/srcio/service-a 因为 service-a 需要依赖本地开发的 service-b 类库，所以我们需要在 go.mod 中引入 service-a ：\nvim go.mod module github.com/srcio/service-a go 1.18 require( github.com/srcio/service-b v1.0.0 ) replace( github.com/srcio/service-a v1.0.0 =\u0026gt; ../service-b ) 然后，编写主函数代码：\nvim main.go package main import( \u0026#34;github.com/srcio/service-b/greeting\u0026#34; ) func main(){ greeting.Hello() } 在上述的整个过程中，你会发现，我们引用了本地的代码类库 github.com/srcio/service-b v1.0.0 =\u0026gt; ../service-b。而且，如果此时别的开发者和你一起协作开发 service-a module的时候，他是无法引用到这个类库的（除非他本地也同步了../service-b）。\n现在你就可以通过 go work 来解决这种烦恼了。\n首先，你要做的是回到module的外面，然后执行 go work init 命令：\ncd .. go work init service-a go work init service-b 此时，你会发现，目录下多了个go.work文件，查看该文件内容：\n$ cat go.work go 1.18 use( ./service-a ./service-b ) module 依赖的类库目录就在 use 块中，此时，你可以删除 service-a目录下 go.mod 中的 replace 块，然后运行 main 函数了：\ncd service-a \u0026amp;\u0026amp; go run main.go # 或者你可以直接在工作区目录运行 go run service-a/main.go 如果你的主项目依赖多个本地类库，那么你可以使用如下命令添加\ngo work use service-c go work use service-d 最后，你可以通过 go help work，了解更多。\n","permalink":"https://blog.srcio.cn/series/programming-go/go-work/","summary":"安装最新的Go1.18版本，它为你提供了工作区模式，帮助你轻松依赖本地类库。\n例如，你开发一个新项目，分了两个 go module，分别为 service-a 和 service-b，service-a 依赖了service-b ，现在项目还处于开发阶段，我们都是这么处理的。\n创建项目目录：\nmkdir service cd service 创建 service-b 模块:\nmkdir service-b cd service-b go mod init github.com/srcio/service-b 编写 service-b 模块代码：\nmkdir greeting vim greeting/hello.go package greeting import \u0026#34;fmt\u0026#34; func Hello(name string){ fmt.Println(\u0026#34;Hello, \u0026#34; + name) } 继续创建 service-a 模块：\ncd .. mkdir service-a cd service-a go mod init github.com/srcio/service-a 因为 service-a 需要依赖本地开发的 service-b 类库，所以我们需要在 go.mod 中引入 service-a ：\nvim go.mod module github.com/srcio/service-a go 1.","title":"Go1.18 - 工作区模式"},{"content":"Giscus  开源、无广告、永久免费 支持多语言 支持表情反馈 支持懒加载  必要条件  你的博客所用的 GitHub 的仓库必须是 Public，并且开通了 Dicussion 功能； 安装 giscus.app，安装的时候，分配你的博客所用的 GitHub 仓库即可。   当然，如果你的博客没有托管在 Github 上，你也可以单独创建一个 Github 仓库作为开通 giscus 评论。\n 使用姿势  在 giscus.app 做自定义配置，填入你的仓库名称，选择主题等，Giscus 会自动帮你生成 javascript 脚本； Hugo 博客目录下，创建 layouts/partials/comments.html 文件，写入获取的脚本：  \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;[在此输入仓库]\u0026#34; data-repo-id=\u0026#34;[在此输入仓库 ID]\u0026#34; data-category=\u0026#34;[在此输入分类名]\u0026#34; data-category-id=\u0026#34;[在此输入分类 ID]\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;light\u0026#34; data-lang=\u0026#34;zh-CN\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt;  ⚠️注意：为了使下面的 javascript 脚本生效，data-theme 选择 light；或者你可以根据你选择的主题修改下面的 javascript 脚本。\n 自动主题  使用一个 div 作为评论区域的容器  \u0026lt;div class=\u0026#34;giscus_comments\u0026#34;\u0026gt; {{- partial \u0026#34;comments.html\u0026#34; . }} \u0026lt;/div\u0026gt; 在该容器下方写入主题自动切换的语句  \u0026lt;script\u0026gt; document.querySelector(\u0026#34;div.giscus_comments \u0026gt; script\u0026#34;) .setAttribute( \u0026#34;data-theme\u0026#34;, localStorage.getItem(\u0026#34;pref-theme\u0026#34;) ? localStorage.getItem(\u0026#34;pref-theme\u0026#34;) : window.matchMedia(\u0026#34;(prefers-color-scheme: dark)\u0026#34;).matches ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;), document.querySelector(\u0026#34;#theme-toggle\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { let e = document.querySelector(\u0026#34;iframe.giscus-frame\u0026#34;); e \u0026amp;\u0026amp; e.contentWindow.postMessage({ giscus: { setConfig: { theme: localStorage.getItem(\u0026#34;pref-theme\u0026#34;) ? localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;dark\u0026#34; ? \u0026#34;light\u0026#34; : \u0026#34;dark\u0026#34; : document.body.className.includes(\u0026#34;dark\u0026#34;) ? \u0026#34;light\u0026#34; : \u0026#34;dark\u0026#34; } } }, \u0026#34;https://giscus.app\u0026#34;) }) \u0026lt;/script\u0026gt; 🔗 链接   应用：https://github.com/apps/giscus\n  源码：https://github.com/giscus/giscus\n  使用：https://giscus.app/\n  ","permalink":"https://blog.srcio.cn/posts/use-giscus/","summary":"Giscus  开源、无广告、永久免费 支持多语言 支持表情反馈 支持懒加载  必要条件  你的博客所用的 GitHub 的仓库必须是 Public，并且开通了 Dicussion 功能； 安装 giscus.app，安装的时候，分配你的博客所用的 GitHub 仓库即可。   当然，如果你的博客没有托管在 Github 上，你也可以单独创建一个 Github 仓库作为开通 giscus 评论。\n 使用姿势  在 giscus.app 做自定义配置，填入你的仓库名称，选择主题等，Giscus 会自动帮你生成 javascript 脚本； Hugo 博客目录下，创建 layouts/partials/comments.html 文件，写入获取的脚本：  \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;[在此输入仓库]\u0026#34; data-repo-id=\u0026#34;[在此输入仓库 ID]\u0026#34; data-category=\u0026#34;[在此输入分类名]\u0026#34; data-category-id=\u0026#34;[在此输入分类 ID]\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;light\u0026#34; data-lang=\u0026#34;zh-CN\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt;  ⚠️注意：为了使下面的 javascript 脚本生效，data-theme 选择 light；或者你可以根据你选择的主题修改下面的 javascript 脚本。\n 自动主题  使用一个 div 作为评论区域的容器  \u0026lt;div class=\u0026#34;giscus_comments\u0026#34;\u0026gt; {{- partial \u0026#34;comments.","title":"使用 Giscus 作为博客评论系统"}]